<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">

    <!-- read in js libraries -->
    <script src="https://unpkg.com/jspsych@7.3.3"></script>

    <!-- Initialize jsPsych -->
    <script src="init-jspsych.js"></script>

    <!-- read in jsPsych plugins -->
    <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.2"></script>
    <script src="https://unpkg.com/@jspsych/plugin-fullscreen@1.1.2"></script>
    <script src="plugins_threebandit.js"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-slider-response@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@1.0.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-multi-select@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey-multi-choice@1.1.3"></script>
    <script src="https://unpkg.com/@jspsych/plugin-survey@1.0.1"></script>
    <script src="https://unpkg.com/@jspsych/plugin-html-button-response@1.2.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-call-function@2.1.0"></script>
    <script src="https://unpkg.com/@jspsych/plugin-instructions@1.1.4"></script>

    <!--  -->
    <script src="runsheet_threebandit.js"></script>
    <script src="stimuli_threebandit.js"></script>
    <script src="threebandit_queues.js"></script> <!-- updated-->


    <!-- read in stylesheets -->
    <link href="https://unpkg.com/jspsych@7.3.3/css/jspsych.css" rel="stylesheet" type="text/css" />
    <link href="style_rating_threebandit.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://unpkg.com/@jspsych/plugin-survey@1.0.1/css/survey.css">
  

  </head>
  <div class="container-rating">
    <h2>Subjective Rating</h2>
    <p>Click inside the triangle to make a judgment.</p>
    <canvas id="triangleCanvas" width="500" height="450"></canvas>
    <div id="tooltip" class="tooltip"></div>
  </div>

  </body>
  <script>

var participant_id = jsPsych.randomization.randomID(10)

// capture info from Prolific
var subject_id = jsPsych.data.getURLVariable('PROLIFIC_PID');
var study_id = jsPsych.data.getURLVariable('STUDY_ID');
var session_id = jsPsych.data.getURLVariable('SESSION_ID');
// pick a random condition for the subject at the start of the experiment
var condition_assignment = jsPsych.randomization.sampleWithoutReplacement(['ind', 'str'], 1)[0];
console.log("Condition: " + condition_assignment)

  jsPsych.data.addProperties({
    subject_id: subject_id,
    study_id: study_id,
    session_id: session_id,
    condition: condition_assignment,
    participant_id: participant_id
  });



// define welcome message
var welcome = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: "Welcome to the experiment. Press any key to begin."
  };

// define block end message
var block_end = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: "End of block. Take a break. and press any key to continue when you are ready.",
    on_finish: function(data){ 
      queues.ind1 = ind1;
      queues.ind2 = ind2;
      queues.ind3 = ind3;
      queues.str1 = str1;
      queues.str2 = str2;
      queues.str3 = str3;
      counter.block += 1;
      counter.trial = 1;
    }
  };


// define experiment end message
var expt_end = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: "End of task. Press any key to quit."
  };

//------------------------------------
// Functions to turn fullscreen on/off
//------------------------------------

  var fullscreen_on = {
    type: jsPsychFullscreen,
    fullscreen_mode: true,
    message: '<p>The experiment will switch to full screen mode when you press the button below.</p><p>Where possible, please stay in full screen mode for the entire experiment.</p>'
  };


  var fullscreen_off = {
    type: jsPsychFullscreen,
    fullscreen_mode: false
  };


//------------------------------------
// Define and randomise experimental variables
//------------------------------------

  // payout queues *without* randomisation, place them in a global variable (so they can be accessed and manipulated independently of the jsPsych trial structure).
  var ind1 = [[],[]];
  var ind2 = [[],[]];
  var ind3 = [[],[]];
  var str1 = [[],[]];
  var str2 = [[],[]];
  var str3 = [[],[]];
  for (var i = 0; i < ind_block1_queue_3arm.length; i++){ // length = 2 (= two options)
    ind1[i] = ind_block1_queue_3arm[i];
    ind2[i] = ind_block2_queue_3arm[i];
    ind3[i] = ind_block3_queue_3arm[i];
    str1[i] = str_block1_queue_3arm[i];
    str2[i] = str_block2_queue_3arm[i];
    str3[i] = str_block3_queue_3arm[i];
  }

  // specify queues
  var queues = {};
    queues.ind1 = ind1;
    queues.ind2 = ind2;
    queues.ind3 = ind3;
    queues.str1 = str1;
    queues.str2 = str2;
    queues.str3 = str3;
    queues.practice = practice_queue_3arm; // practice trials


  // set up block and trial counters
  var counter = {};
  counter.block = 1;
  counter.trial = 1;
  counter.n_blocks = 3; 

  
  //------------------------------------
  // Rating trials
  //------------------------------------

  // intervals between rating trials
  var intervR = [5, 6, 5, 5, 7, 8, 7, 8, 5, 6, 9, 5, 6, 7, 6, 6, 8, 6, 7, 7, 5, 7, 9]; // length = 23
  var sampleSize = function() {
    var size = intervR[0]; // Retrieve the first value
    intervR.shift();       // Remove the first value
    return size; 
    }   


  var clickHistory = []; // Array to store all click data

  var ratingTrial = { 
    type: jsPsychHtmlButtonResponse,
    stimulus: `
      <div class="container-rating">
          <h2>Subjective Rating</h2>
          <p>What are the chances (%) that each option is currently the best one?</p>
          <p>Click inside the triangle to make a judgment.</p>
          <canvas id="triangleCanvas" width="500" height="450"></canvas>
          <div id="tooltip" class="tooltip"></div>
      </div>`,
    choices: ['Submit'], 
    button_html: '<button id="submit-button" disabled>%choice%</button>', // Initially disabled
    on_load: function () {
      const canvas = document.getElementById("triangleCanvas");
      const submitButton = document.getElementById("submit-button");
      const ctx = canvas.getContext("2d");
      const tooltip = document.getElementById("tooltip");

      clickHistory = [];
        
      // Larger triangle vertices (keeping equilateral structure)
      const A = { x: 250, y: 50 };   // Top (Option A, Blue)
      const B = { x: 50, y: 400 };   // Bottom Left (Option B, Red)
      const C = { x: 450, y: 400 };  // Bottom Right (Option C, Green)

      function drawTriangle() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          // Create a gradient fill from each corner fading towards the center
          const gradientCanvas = document.createElement("canvas");
          gradientCanvas.width = canvas.width;
          gradientCanvas.height = canvas.height;
          const gCtx = gradientCanvas.getContext("2d");
          
          const gradientA = gCtx.createLinearGradient(A.x, A.y, 250, 250);
          gradientA.addColorStop(0, "rgba(0, 123, 255, 1)"); // Blue at A
          gradientA.addColorStop(1, "rgba(255, 255, 255, 0.1)"); // White center
          gCtx.fillStyle = gradientA;
          gCtx.beginPath();
          gCtx.moveTo(A.x, A.y);
          gCtx.lineTo(B.x, B.y);
          gCtx.lineTo(C.x, C.y);
          gCtx.closePath();
          gCtx.fill();
          
          const gradientB = gCtx.createLinearGradient(B.x, B.y, 250, 250);
          gradientB.addColorStop(0, "rgba(255, 0, 0, 1)"); // Red at B
          gradientB.addColorStop(1, "rgba(255, 255, 255, 0.1)"); // White center
          gCtx.fillStyle = gradientB;
          gCtx.fill();
          
          const gradientC = gCtx.createLinearGradient(C.x, C.y, 250, 250);
          gradientC.addColorStop(0, "rgba(0, 128, 0, 1)"); // Green at C
          gradientC.addColorStop(1, "rgba(255, 255, 255, 0.1)"); // White center
          gCtx.fillStyle = gradientC;
          gCtx.fill();
          
          ctx.drawImage(gradientCanvas, 0, 0);
          ctx.stroke();
          
          // Labels
          // Display "A" in blue
          ctx.fillStyle = "blue";
          ctx.font = "16px Arial";
          ctx.fillText("A", A.x - 5, A.y - 10);

          // Display "B" in red
          ctx.fillStyle = "red";
          ctx.fillText("B", B.x - 10, B.y + 20);

          // Display "C" in green
          ctx.fillStyle = "green";
          ctx.fillText("C", C.x + 10, C.y + 20);
      }
      drawTriangle();

      function isInsideTriangle(px, py) {
          const area = Math.abs((A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y)) / 2);
          const area1 = Math.abs((px*(B.y-C.y) + B.x*(C.y-py) + C.x*(py-B.y)) / 2);
          const area2 = Math.abs((A.x*(py-C.y) + px*(C.y-A.y) + C.x*(A.y-py)) / 2);
          const area3 = Math.abs((A.x*(B.y-py) + B.x*(py-A.y) + px*(A.y-B.y)) / 2);
          return (area === area1 + area2 + area3);
      }

      function getBarycentricWeights(px, py) {
          const denominator = (B.y - C.y) * (A.x - C.x) + (C.x - B.x) * (A.y - C.y);
          const wa = ((B.y - C.y) * (px - C.x) + (C.x - B.x) * (py - C.y)) / denominator;
          const wb = ((C.y - A.y) * (px - C.x) + (A.x - C.x) * (py - C.y)) / denominator;
          const wc = 1 - wa - wb;
          return [wa, wb, wc];
      }
      
      canvas.addEventListener("click", function(event) {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        if (isInsideTriangle(x, y)) {
            drawTriangle();
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();

            const [wa, wb, wc] = getBarycentricWeights(x, y);
            const relA = wa * 100;
            const relB = wb * 100;
            const relC = wc * 100;

            // Store the click in the array
            clickHistory.push({ A: relA, B: relB, C: relC });


            finalRelA = relA;
            finalRelB = relB;
            finalRelC = relC;

            tooltip.style.display = "block";
            tooltip.style.left = `${event.clientX + 10}px`;
            tooltip.style.top = `${event.clientY + 10}px`;
            tooltip.innerHTML = `A: ${Math.round(relA)} % | B: ${Math.round(relB)} % | C: ${Math.round(relC)} %`;

          }

          if (isInsideTriangle(x, y)) {
          submitButton.disabled = false; // Enable the button
        }

      });

      
    },
    on_finish: function(data) {
      // Store final ratings from tooltip
      data.A_rating = finalRelA;
      data.B_rating = finalRelB;
      data.C_rating = finalRelC;
      data.clickHistory = clickHistory;
      console.log(`Ratings captured: A = ${finalRelA}, B = ${finalRelB}, C = ${finalRelC}`);
    }
  };

  //------------------------------------
  // Instructions for the rating
  //------------------------------------

  var instructions_rating = {
    type: jsPsychInstructions,
    pages: [ // page 1: basic information, page 2: positioning, page 3: examples, page 4: introduction practice trials
      `
      <div style="display: flex; flex-direction: column; align-items: center; padding: 10px; gap: 10px; max-width: 800px; margin: auto;">
          <div style="text-align: center; width: 100%; font-size: 20px;">
            <p><strong>Rating Task: Judging the Best Option</strong></p>
          </div>
          <div style="text-align: left; width: 100%;">
            <p>Every now and then, you will be asked to make a judgment about the choice alternatives. Specifically, your job is to estimate the <strong>chances (%)</strong> that each option will give the most points.</p>
            
            <p>You will see a triangle on the screen that looks like this:</p>
          </div>
          <div style="display: flex; align-items: center; justify-content: center; border: 1px solid black;">
            <img src="triangle_example.png" alt="Triangle Rating Example" width="600">
          </div>
          <div style="text-align: left; width: 100%;">
            <p>Each corner represents one choice alternative: <strong>A, B, or C</strong>.</p>
            <p><strong>Click anywhere inside the triangle</strong> to make your judgment.</p>
          </div>
      </div>
      `,
      `
        <div style="display: flex; flex-direction: column; align-items: center; padding: 10px; gap: 10px; max-width: 1500px; margin: auto;">
          <div style="text-align: center; width: 100%; font-size: 20px;">
            <p><strong>Rating Task: Judging the Best Option</strong></p>
          </div>
          <div style="display: flex; align-items: center; justify-content: center; border: 1px solid black;">
            <img src="triangle_example.png" alt="Triangle Rating Example" width="600">
          </div>
          <div style="text-align: left; width: 100%;">
            <p>Where you click represents your belief about the best option:</p>
                <ul>
                    <li><strong>Closer to a corner:</strong> You believe that option is clearly the best.</li>
                    <li><strong>In the middle:</strong> You think all three options are about equal.</li>
                    <li><strong>Near the edge between two corners:</strong> You believe those two options are similar, while the third is worse.</li>
                </ul>
                <p>A textbox will appear where you click that displays the exact percentages corresponding to the position of the click inside the triangle.</p>
                <p>On the next page, you will see some examples.</p>
          </div>
        </div>
        `,
        `
        <div style="display: flex; flex-direction: column; align-items: center; padding: 10px; gap: 10px; max-width: 1500px; margin: auto;">
          <div style="text-align: center; font-size: 20px;">
              <p><strong>Examples:</strong></p>
            </div>
            <div style="display: flex; justify-content: center; gap: 20px;">
              <div>
                <p style="min-height: 60px;">You think A is clearly the best?</p>
                <div style="border: 1px solid black;">
                  <img src="exampleA_best.png" alt="Example A Best" width="450">
                </div>
              </div>
              <div style="display: flex; flex-direction: column; align-items: center; text-align: center; width: 450px;">
                <p style="min-height: 60px";>You think B is slightly better than A, and C is bad?</p>
                <div style="border: 1px solid black;">
                  <img src="exampleB_slightly_better.png" alt="Example B Slightly Better" width="450">
                </div>
              </div>
              <div style="display: flex; flex-direction: column; align-items: center; text-align: center; width: 450px;">
                <p style="min-height: 60px";>You are unsure which is best, but A is probably the worst?</p>
                <div style="border: 1px solid black;">
                  <img src="exampleA_worst.png" alt="Example A Worst" width="450">
                </div>
              </div>
            </div>
            <div style="text-align: left;">
              <p>You can change your judgment as often as you like by clicking at a different position. When your judgment is final, click the <strong>"Submit"</strong> button.</p>
              <p><em>It is <strong>not</strong> important that your judgment is correct. We are interested in what you <strong>think</strong> is the best option.</em></p>
            </div>
          </div>
        </div>
        `,
          `
        <div style="display: flex; flex-direction: column; align-items: center; padding: 10px; gap: 10px; max-width: 1500px; margin: auto;">
          <div style="text-align: center; font-size: 20px;">
              <p><strong>Now it's your turn again!</strong></p>
            </div>
            <div style="display: flex; justify-content: center; gap: 20px;">
            <div style="text-align: left; width: 700px;">
              <p>You will now complete <strong>three practice trials</strong>, during which you will be shown a belief about the values of the options. Your job is to click at a position inside the triangle that corresponds to this belief.</p>
              <p>You will also receive feedback.</p>
            </div>
          </div>
        </div>
        `
      ],
      show_clickable_nav: true,  // Enables navigation buttons
      button_label_next: "Next",
      button_label_previous: "Back"  // Enables the "Back" button
    };

 

    //------------------------------------
    // Practice trials - Rating task
    //------------------------------------   


    var practiceRatingTrial_1 = { 
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="container-rating">
            <h2>Practice Trial 1 of 3</h2>
            <p><em>"You are sure that C is the best option."</em></p>
            <p>Click inside the triangle to make a judgment.</p>
            <canvas id="triangleCanvas" width="500" height="450"></canvas>
            <div id="tooltip" class="tooltip"></div>
        </div>
        <div id="feedbackBox" style="display: none; border: 2px solid black; padding: 10px; font-weight: bold; position: absolute; border-radius: 50%; width: 85px; height: 85px; transform: translate(-50%, -50%);"></div>
        <div id="feedbackText" style="display: none; text-align: center; position: absolute; font-size: 16px;">
          <p>This area represents strong confidence in C.</p>
        </div>`,
      choices: ['Submit'], 
      button_html: '<button id="submit-button" disabled>%choice%</button>', // Initially disabled
      on_load: function () {
        const canvas = document.getElementById("triangleCanvas");
        const submitButton = document.getElementById("submit-button");
        const ctx = canvas.getContext("2d");
        const tooltip = document.getElementById("tooltip");
        const feedbackBox = document.getElementById("feedbackBox");
        
        clickHistory = []; 
          
        // Larger triangle vertices (keeping equilateral structure)
        const A = { x: 250, y: 50 };   // Top (Option A, Blue)
        const B = { x: 50, y: 400 };   // Bottom Left (Option B, Red)
        const C = { x: 450, y: 400 };  // Bottom Right (Option C, Green)


        function drawTriangle() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Create a gradient fill from each corner fading towards the center
            const gradientCanvas = document.createElement("canvas");
            gradientCanvas.width = canvas.width;
            gradientCanvas.height = canvas.height;
            const gCtx = gradientCanvas.getContext("2d");
            
            const gradientA = gCtx.createLinearGradient(A.x, A.y, 250, 250);
            gradientA.addColorStop(0, "rgba(0, 123, 255, 1)"); // Blue at A
            gradientA.addColorStop(1, "rgba(255, 255, 255, 0.1)"); // White center
            gCtx.fillStyle = gradientA;
            gCtx.beginPath();
            gCtx.moveTo(A.x, A.y);
            gCtx.lineTo(B.x, B.y);
            gCtx.lineTo(C.x, C.y);
            gCtx.closePath();
            gCtx.fill();
            
            const gradientB = gCtx.createLinearGradient(B.x, B.y, 250, 250);
            gradientB.addColorStop(0, "rgba(255, 0, 0, 1)"); // Red at B
            gradientB.addColorStop(1, "rgba(255, 255, 255, 0.1)"); // White center
            gCtx.fillStyle = gradientB;
            gCtx.fill();
            
            const gradientC = gCtx.createLinearGradient(C.x, C.y, 250, 250);
            gradientC.addColorStop(0, "rgba(0, 128, 0, 1)"); // Green at C
            gradientC.addColorStop(1, "rgba(255, 255, 255, 0.1)"); // White center
            gCtx.fillStyle = gradientC;
            gCtx.fill();
            
            ctx.drawImage(gradientCanvas, 0, 0);
            ctx.stroke();
            
            // Labels
            // Display "A" in blue
            ctx.fillStyle = "blue";
            ctx.font = "16px Arial";
            ctx.fillText("A", A.x - 5, A.y - 10);

            // Display "B" in red
            ctx.fillStyle = "red";
            ctx.fillText("B", B.x - 10, B.y + 20);

            // Display "C" in green
            ctx.fillStyle = "green";
            ctx.fillText("C", C.x + 10, C.y + 20);
        }
        drawTriangle();

        function drawArrow(ctx, startX, startY, length, angle) {
          // Set arrow properties
          const arrowWidth = 10;  // Width of the arrowhead
          const angleOffset = Math.PI / 6;  // Angle of the arrowhead spread

          // Calculate the end point of the arrow based on the angle
          const endX = startX + length * Math.cos(angle);
          const endY = startY + length * Math.sin(angle);

          // Draw the line (shaft of the arrow)
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
          ctx.stroke();

          // Draw the arrowhead
          const angle1 = angle + angleOffset;  // Left side of the arrowhead
          const angle2 = angle - angleOffset;  // Right side of the arrowhead

          // Calculate arrowhead points
          const arrowheadX1 = startX + arrowWidth * Math.cos(angle1);
          const arrowheadY1 = startY + arrowWidth * Math.sin(angle1);

          const arrowheadX2 = startX + arrowWidth * Math.cos(angle2);
          const arrowheadY2 = startY + arrowWidth * Math.sin(angle2);

          // Draw the arrowhead lines
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(arrowheadX1, arrowheadY1);
          ctx.moveTo(startX, startY);
          ctx.lineTo(arrowheadX2, arrowheadY2);
          ctx.stroke();
      }

        function isInsideTriangle(px, py) {
            const area = Math.abs((A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y)) / 2);
            const area1 = Math.abs((px*(B.y-C.y) + B.x*(C.y-py) + C.x*(py-B.y)) / 2);
            const area2 = Math.abs((A.x*(py-C.y) + px*(C.y-A.y) + C.x*(A.y-py)) / 2);
            const area3 = Math.abs((A.x*(B.y-py) + B.x*(py-A.y) + px*(A.y-B.y)) / 2);
            return (area === area1 + area2 + area3);
        }

        function getBarycentricWeights(px, py) {
            const denominator = (B.y - C.y) * (A.x - C.x) + (C.x - B.x) * (A.y - C.y);
            const wa = ((B.y - C.y) * (px - C.x) + (C.x - B.x) * (py - C.y)) / denominator;
            const wb = ((C.y - A.y) * (px - C.x) + (A.x - C.x) * (py - C.y)) / denominator;
            const wc = 1 - wa - wb;
            return [wa, wb, wc];
        }
        
        canvas.addEventListener("click", function(event) {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;

          if (isInsideTriangle(x, y)) {
              drawTriangle();
              ctx.fillStyle = "black";
              ctx.beginPath();
              ctx.arc(x, y, 5, 0, Math.PI * 2);
              ctx.fill();

              const [wa, wb, wc] = getBarycentricWeights(x, y);
              const relA = wa * 100;
              const relB = wb * 100;
              const relC = wc * 100;

              // Store the click in the array
              clickHistory.push({ A: relA, B: relB, C: relC });

              finalRelA = relA;
              finalRelB = relB;
              finalRelC = relC;

              tooltip.style.display = "block";
              tooltip.style.left = `480px`;
              tooltip.style.top = `500px`;
              tooltip.innerHTML = `A: ${Math.round(relA)} % | B: ${Math.round(relB)} % | C: ${Math.round(relC)} %`;


              // Show feedback box immediately
              feedbackBox.style.display = "block";
              feedbackBox.style.left = `910px`;
              feedbackBox.style.top = `700px`; // Position it above C slightly

              // show feedback text at the same time
              feedbackText.style.display = "block";
              feedbackText.style.right = `220px`;
              feedbackText.style.top = `550px`;

              // Draw an arrow starting from (450, 320) with a length of 50 and pointing 45 degrees (in radiants)
              drawArrow(ctx, 450, 320, 50, -.785);  

              // Disable the button initially
              submitButton.disabled = true;

              // Enable the submit button after 2 seconds
              setTimeout(function () {
                  submitButton.disabled = false;
              }, 1500);
          }

        });
          
        },
        on_finish: function(data) {
          // Store final ratings from tooltip
          data.A_rating = finalRelA;
          data.B_rating = finalRelB;
          data.C_rating = finalRelC;
          data.clickHistory = clickHistory;
        console.log(`Ratings captured: A = ${finalRelA}, B = ${finalRelB}, C = ${finalRelC}`);
        }
      };

    
    var practiceRatingTrial_2 = { 
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="container-rating">
            <h2>Practice Trial 2 of 3</h2>
            <p><em>"You think B and C are about equally good, and A is unlikely."</em></p>
            <p>Click inside the triangle to make a judgment.</p>
            <canvas id="triangleCanvas" width="500" height="450"></canvas>
            <div id="tooltip" class="tooltip"></div>
        </div>
        <div id="feedbackBox" style="display: none; border: 2px solid black; padding: 10px; font-weight: bold; position: absolute; border-radius: 50%; width: 120px; height: 70px; transform: translate(-50%, -50%);"></div>
        <div id="feedbackText" style="display: none; text-align: center; position: absolute; font-size: 16px;">
          <p>This area corresponds to the statement above.</p>
        </div>`,
      choices: ['Submit'], 
      button_html: '<button id="submit-button" disabled>%choice%</button>', // Initially disabled
      on_load: function () {
        const canvas = document.getElementById("triangleCanvas");
        const submitButton = document.getElementById("submit-button");
        const ctx = canvas.getContext("2d");
        const tooltip = document.getElementById("tooltip");

        clickHistory = [];
          
        // Larger triangle vertices (keeping equilateral structure)
        const A = { x: 250, y: 50 };   // Top (Option A, Blue)
        const B = { x: 50, y: 400 };   // Bottom Left (Option B, Red)
        const C = { x: 450, y: 400 };  // Bottom Right (Option C, Green)

        function drawTriangle() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Create a gradient fill from each corner fading towards the center
            const gradientCanvas = document.createElement("canvas");
            gradientCanvas.width = canvas.width;
            gradientCanvas.height = canvas.height;
            const gCtx = gradientCanvas.getContext("2d");
            
            const gradientA = gCtx.createLinearGradient(A.x, A.y, 250, 250);
            gradientA.addColorStop(0, "rgba(0, 123, 255, 1)"); // Blue at A
            gradientA.addColorStop(1, "rgba(255, 255, 255, 0.1)"); // White center
            gCtx.fillStyle = gradientA;
            gCtx.beginPath();
            gCtx.moveTo(A.x, A.y);
            gCtx.lineTo(B.x, B.y);
            gCtx.lineTo(C.x, C.y);
            gCtx.closePath();
            gCtx.fill();
            
            const gradientB = gCtx.createLinearGradient(B.x, B.y, 250, 250);
            gradientB.addColorStop(0, "rgba(255, 0, 0, 1)"); // Red at B
            gradientB.addColorStop(1, "rgba(255, 255, 255, 0.1)"); // White center
            gCtx.fillStyle = gradientB;
            gCtx.fill();
            
            const gradientC = gCtx.createLinearGradient(C.x, C.y, 250, 250);
            gradientC.addColorStop(0, "rgba(0, 128, 0, 1)"); // Green at C
            gradientC.addColorStop(1, "rgba(255, 255, 255, 0.1)"); // White center
            gCtx.fillStyle = gradientC;
            gCtx.fill();
            
            ctx.drawImage(gradientCanvas, 0, 0);
            ctx.stroke();
            
            // Labels
            // Display "A" in blue
            ctx.fillStyle = "blue";
            ctx.font = "16px Arial";
            ctx.fillText("A", A.x - 5, A.y - 10);

            // Display "B" in red
            ctx.fillStyle = "red";
            ctx.fillText("B", B.x - 10, B.y + 20);

            // Display "C" in green
            ctx.fillStyle = "green";
            ctx.fillText("C", C.x + 10, C.y + 20);
        }
        drawTriangle();

        function drawArrow(ctx, startX, startY, length, angle) {
          // Set arrow properties
          const arrowWidth = 10;  // Width of the arrowhead
          const angleOffset = Math.PI / 6;  // Angle of the arrowhead spread

          // Calculate the end point of the arrow based on the angle
          const endX = startX + length * Math.cos(angle);
          const endY = startY + length * Math.sin(angle);

          // Draw the line (shaft of the arrow)
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
          ctx.stroke();

          // Draw the arrowhead
          const angle1 = angle + angleOffset;  // Left side of the arrowhead
          const angle2 = angle - angleOffset;  // Right side of the arrowhead

          // Calculate arrowhead points
          const arrowheadX1 = startX + arrowWidth * Math.cos(angle1);
          const arrowheadY1 = startY + arrowWidth * Math.sin(angle1);

          const arrowheadX2 = startX + arrowWidth * Math.cos(angle2);
          const arrowheadY2 = startY + arrowWidth * Math.sin(angle2);

          // Draw the arrowhead lines
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(arrowheadX1, arrowheadY1);
          ctx.moveTo(startX, startY);
          ctx.lineTo(arrowheadX2, arrowheadY2);
          ctx.stroke();
      }

        function isInsideTriangle(px, py) {
            const area = Math.abs((A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y)) / 2);
            const area1 = Math.abs((px*(B.y-C.y) + B.x*(C.y-py) + C.x*(py-B.y)) / 2);
            const area2 = Math.abs((A.x*(py-C.y) + px*(C.y-A.y) + C.x*(A.y-py)) / 2);
            const area3 = Math.abs((A.x*(B.y-py) + B.x*(py-A.y) + px*(A.y-B.y)) / 2);
            return (area === area1 + area2 + area3);
        }

        function getBarycentricWeights(px, py) {
            const denominator = (B.y - C.y) * (A.x - C.x) + (C.x - B.x) * (A.y - C.y);
            const wa = ((B.y - C.y) * (px - C.x) + (C.x - B.x) * (py - C.y)) / denominator;
            const wb = ((C.y - A.y) * (px - C.x) + (A.x - C.x) * (py - C.y)) / denominator;
            const wc = 1 - wa - wb;
            return [wa, wb, wc];
        }
        
        canvas.addEventListener("click", function(event) {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;

          if (isInsideTriangle(x, y)) {
              drawTriangle();
              ctx.fillStyle = "black";
              ctx.beginPath();
              ctx.arc(x, y, 5, 0, Math.PI * 2);
              ctx.fill();

              const [wa, wb, wc] = getBarycentricWeights(x, y);
              const relA = wa * 100;
              const relB = wb * 100;
              const relC = wc * 100;

              // Store the click in the array
              clickHistory.push({ A: relA, B: relB, C: relC });

              finalRelA = relA;
              finalRelB = relB;
              finalRelC = relC;

              tooltip.style.display = "block";
              tooltip.style.left = `480px`;
              tooltip.style.top = `500px`;
              tooltip.innerHTML = `A: ${Math.round(relA)} % | B: ${Math.round(relB)} % | C: ${Math.round(relC)} %`;

            // Show feedback box immediately
            feedbackBox.style.display = "block";
            feedbackBox.style.left = `750px`;
            feedbackBox.style.top = `690px`; // Position it at the bottom of the triangle, in the middle between B and C

            // show feedback text at the same time
            feedbackText.style.display = "block";
            feedbackText.style.right = `220px`;
            feedbackText.style.top = `530px`;

            // Draw an arrow starting from (330, 330) with a length of 120 and pointing -40 degrees
            drawArrow(ctx, 330, 330, 120, -0.7);  

            // Disable the button initially
            submitButton.disabled = true;

            // Enable the submit button after 2 seconds
            setTimeout(function () {
                submitButton.disabled = false;
            }, 1500);
          }

        });

        
      },
      on_finish: function(data) {
        // Store final ratings from tooltip
        data.A_rating = finalRelA;
        data.B_rating = finalRelB;
        data.C_rating = finalRelC;
        data.clickHistory = clickHistory;
        console.log(`Ratings captured: A = ${finalRelA}, B = ${finalRelB}, C = ${finalRelC}`);
      }
    };


    var practiceRatingTrial_3 = { 
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="container-rating">
            <h2>Practice Trial 3 of 3</h2>
            <p style="width: 800px;"><em>"You have only chosen A in the past 10 trials, because it yielded a high number of points. So you know that A is good. B and C are probably worse, but you are unsure about their value."</em></p>
            <p>Click inside the triangle to make a judgment.</p>
            <canvas id="triangleCanvas" width="500" height="450"></canvas>
            <div id="tooltip" class="tooltip"></div>
        </div>
        <div id="feedbackBox" style="display: none; border: 2px solid black; padding: 10px; font-weight: bold; position: absolute; border-radius: 50%; width: 85px; height: 85px; transform: translate(-50%, -50%);"></div>
        <div id="feedbackText" style="display: none; text-align: center; position: absolute; font-size: 16px; width: 400px;">
          <p>This area represents the belief that A is probably better than B and C (closest to the A corner), but that confidence is lower due to the uncertainty regarding the value of the latter two (a bit away from the corner).</p>
        </div>`,
      choices: ['Submit'], 
      button_html: '<button id="submit-button" disabled>%choice%</button>', // Initially disabled
      on_load: function () {
        const canvas = document.getElementById("triangleCanvas");
        const submitButton = document.getElementById("submit-button");
        const ctx = canvas.getContext("2d");
        const tooltip = document.getElementById("tooltip");

        clickHistory = [];
          
        // Larger triangle vertices (keeping equilateral structure)
        const A = { x: 250, y: 50 };   // Top (Option A, Blue)
        const B = { x: 50, y: 400 };   // Bottom Left (Option B, Red)
        const C = { x: 450, y: 400 };  // Bottom Right (Option C, Green)

        function drawTriangle() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Create a gradient fill from each corner fading towards the center
            const gradientCanvas = document.createElement("canvas");
            gradientCanvas.width = canvas.width;
            gradientCanvas.height = canvas.height;
            const gCtx = gradientCanvas.getContext("2d");
            
            const gradientA = gCtx.createLinearGradient(A.x, A.y, 250, 250);
            gradientA.addColorStop(0, "rgba(0, 123, 255, 1)"); // Blue at A
            gradientA.addColorStop(1, "rgba(255, 255, 255, 0.1)"); // White center
            gCtx.fillStyle = gradientA;
            gCtx.beginPath();
            gCtx.moveTo(A.x, A.y);
            gCtx.lineTo(B.x, B.y);
            gCtx.lineTo(C.x, C.y);
            gCtx.closePath();
            gCtx.fill();
            
            const gradientB = gCtx.createLinearGradient(B.x, B.y, 250, 250);
            gradientB.addColorStop(0, "rgba(255, 0, 0, 1)"); // Red at B
            gradientB.addColorStop(1, "rgba(255, 255, 255, 0.1)"); // White center
            gCtx.fillStyle = gradientB;
            gCtx.fill();
            
            const gradientC = gCtx.createLinearGradient(C.x, C.y, 250, 250);
            gradientC.addColorStop(0, "rgba(0, 128, 0, 1)"); // Green at C
            gradientC.addColorStop(1, "rgba(255, 255, 255, 0.1)"); // White center
            gCtx.fillStyle = gradientC;
            gCtx.fill();
            
            ctx.drawImage(gradientCanvas, 0, 0);
            ctx.stroke();
            
            // Labels
            // Display "A" in blue
            ctx.fillStyle = "blue";
            ctx.font = "16px Arial";
            ctx.fillText("A", A.x - 5, A.y - 10);

            // Display "B" in red
            ctx.fillStyle = "red";
            ctx.fillText("B", B.x - 10, B.y + 20);

            // Display "C" in green
            ctx.fillStyle = "green";
            ctx.fillText("C", C.x + 10, C.y + 20);
        }
        drawTriangle();

        function drawArrow(ctx, startX, startY, length, angle) {
          // Set arrow properties
          const arrowWidth = 10;  // Width of the arrowhead
          const angleOffset = Math.PI / 6;  // Angle of the arrowhead spread

          // Calculate the end point of the arrow based on the angle
          const endX = startX + length * Math.cos(angle);
          const endY = startY + length * Math.sin(angle);

          // Draw the line (shaft of the arrow)
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
          ctx.stroke();

          // Draw the arrowhead
          const angle1 = angle + angleOffset;  // Left side of the arrowhead
          const angle2 = angle - angleOffset;  // Right side of the arrowhead

          // Calculate arrowhead points
          const arrowheadX1 = startX + arrowWidth * Math.cos(angle1);
          const arrowheadY1 = startY + arrowWidth * Math.sin(angle1);

          const arrowheadX2 = startX + arrowWidth * Math.cos(angle2);
          const arrowheadY2 = startY + arrowWidth * Math.sin(angle2);

          // Draw the arrowhead lines
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(arrowheadX1, arrowheadY1);
          ctx.moveTo(startX, startY);
          ctx.lineTo(arrowheadX2, arrowheadY2);
          ctx.stroke();
      }

        function isInsideTriangle(px, py) {
            const area = Math.abs((A.x*(B.y-C.y) + B.x*(C.y-A.y) + C.x*(A.y-B.y)) / 2);
            const area1 = Math.abs((px*(B.y-C.y) + B.x*(C.y-py) + C.x*(py-B.y)) / 2);
            const area2 = Math.abs((A.x*(py-C.y) + px*(C.y-A.y) + C.x*(A.y-py)) / 2);
            const area3 = Math.abs((A.x*(B.y-py) + B.x*(py-A.y) + px*(A.y-B.y)) / 2);
            return (area === area1 + area2 + area3);
        }

        function getBarycentricWeights(px, py) {
            const denominator = (B.y - C.y) * (A.x - C.x) + (C.x - B.x) * (A.y - C.y);
            const wa = ((B.y - C.y) * (px - C.x) + (C.x - B.x) * (py - C.y)) / denominator;
            const wb = ((C.y - A.y) * (px - C.x) + (A.x - C.x) * (py - C.y)) / denominator;
            const wc = 1 - wa - wb;
            return [wa, wb, wc];
        }
        
        canvas.addEventListener("click", function(event) {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;

          if (isInsideTriangle(x, y)) {
              drawTriangle();
              ctx.fillStyle = "black";
              ctx.beginPath();
              ctx.arc(x, y, 5, 0, Math.PI * 2);
              ctx.fill();

              const [wa, wb, wc] = getBarycentricWeights(x, y);
              const relA = wa * 100;
              const relB = wb * 100;
              const relC = wc * 100;

              // Store the click in the array
              clickHistory.push({ A: relA, B: relB, C: relC });

              finalRelA = relA;
              finalRelB = relB;
              finalRelC = relC;

              clickHistoryA = clickHistory.A
              clickHistoryB = clickHistory.B
              clickHistoryC = clickHistory.C

              tooltip.style.display = "block";
              tooltip.style.left = `480px`;
              tooltip.style.top = `500px`;
              tooltip.innerHTML = `A: ${Math.round(relA)} % | B: ${Math.round(relB)} % | C: ${Math.round(relC)} %`;
              tooltip.style.zIndex = 1000;  // Set the tooltip to appear on top

            // Show feedback box immediately
            feedbackBox.style.display = "block";
            feedbackBox.style.left = `755px`;
            feedbackBox.style.top = `520px`; // Position it towards A, in the middle between B and C

            // show feedback text at the same time
            feedbackText.style.display = "block";
            feedbackText.style.right = `200px`;
            feedbackText.style.top = `430px`;

            // Draw an arrow starting from (330, 180) with a length of 70 and pointing 0 degrees (left)
            drawArrow(ctx, 320, 180, 70, 0);  

            // Disable the button initially
            submitButton.disabled = true;

            // Enable the submit button after 2 seconds
            setTimeout(function () {
                submitButton.disabled = false;
            }, 1500);
          }

        });

        
      },
      on_finish: function(data) {
        // Store final ratings from tooltip
        data.A_rating = finalRelA;
        data.B_rating = finalRelB;
        data.C_rating = finalRelC;
        data.clickHistory = clickHistory;
        console.log(`Ratings captured: A = ${finalRelA}, B = ${finalRelB}, C = ${finalRelC}`);
      }
    };

    
    var practice_rating_loop = {
      timeline: [practiceRatingTrial_1, practiceRatingTrial_2, practiceRatingTrial_3], 
      repetitions: 1, //
      randomize_order: false,
      };


  // slider rating - alternative to triangle method

  var range_trial = { 
    type: jsPsychHtmlButtonResponse,
    choices: [], // no default buttons
    stimulus: `
    <p class="stimulus-text">
      How many points do you expect to obtain if you chose "A", "B" or "C" in the next trial?
    </p>
  `,
  on_load: function () {
    let ranges = {
      A: { lower: 25, upper: 75 },
      B: { lower: 25, upper: 75 },
      C: { lower: 25, upper: 75 }
    };
    let colors = {
      A: "blue",
      B: "red",
      C: "green"
    };
    function createSlider(label) {
      return `
      <div class="slider-container">
        <span class="slider-label" style="color: ${colors[label]}">${label}</span>
        <div class="range-slider">
          <div class="slider-track"></div> 
          <input type="range" min="0" max="100" value="25" class="slider" id="${label}-lower" step="1">
          <input type="range" min="0" max="100" value="75" class="slider" id="${label}-upper" step="1">
          <div class="range-bar" id="${label}-bar" style="background: ${colors[label]}; left: 25%; width: 50%;"></div>
        </div>
        <span id="${label}-output">Range: 25 - 75</span> <!-- Show default range from the start -->
      </div>
      `;
    }
    let htmlContent = `
      <div class="container">
        ${createSlider("A")}
        ${createSlider("B")}
        ${createSlider("C")}
        <button id="confirm-btn" class="confirm-button" disabled>Confirm</button>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', htmlContent); // Insert into the page

    // Object to track slider adjustments
    let slidersAdjusted = { A: false, B: false, C: false };
    function updateRange(label) {
      let lower = document.getElementById(`${label}-lower`);
      let upper = document.getElementById(`${label}-upper`);
      let bar = document.getElementById(`${label}-bar`);
      let output = document.getElementById(`${label}-output`);

      let minVal = parseInt(lower.value);
      let maxVal = parseInt(upper.value);

      if (minVal > maxVal) {
        [minVal, maxVal] = [maxVal, minVal]; // Swap if reversed
      }

      ranges[label].lower = minVal;
      ranges[label].upper = maxVal;
      output.textContent = `Range: ${minVal} - ${maxVal}`;

      slidersAdjusted[label] = true; // Mark slider as adjusted

      let percentMin = (minVal / 100) * 100;
      let percentMax = (maxVal / 100) * 100;
      bar.style.left = percentMin + "%";
      bar.style.width = (percentMax - percentMin) + "%";

      // Enable confirm button if all sliders have been adjusted
      checkAllSlidersAdjusted();
    }
    
    // Function to check if all sliders have been adjusted
    function checkAllSlidersAdjusted() {
      const confirmButton = document.getElementById('confirm-btn');
      if (slidersAdjusted.A && slidersAdjusted.B && slidersAdjusted.C) {
        confirmButton.disabled = false;  // Enable button if all sliders adjusted
      } else {
        confirmButton.disabled = true;   // Disable button otherwise
      }
    }

  // Event listeners for the sliders to call updateRange when input changes
    document.getElementById('A-lower').addEventListener('input', function() {
      updateRange('A');
    });
    document.getElementById('A-upper').addEventListener('input', function() {
      updateRange('A');
    });

    document.getElementById('B-lower').addEventListener('input', function() {
      updateRange('B');
    });
    document.getElementById('B-upper').addEventListener('input', function() {
      updateRange('B');
    });

    document.getElementById('C-lower').addEventListener('input', function() {
      updateRange('C');
    });
    document.getElementById('C-upper').addEventListener('input', function() {
      updateRange('C');
    });

    // Add event listener to the Confirm button
    document.getElementById('confirm-btn').addEventListener('click', function () {
      jsPsych.finishTrial(); // Finish the trial when Confirm is clicked
    });
  },
  on_finish: function(data) {
    // extract slider ranges
    const ARange = {
      lower: parseInt(document.getElementById('A-lower').value),
      upper: parseInt(document.getElementById('A-upper').value)
    };
    const BRange = {
      lower: parseInt(document.getElementById('B-lower').value),
      upper: parseInt(document.getElementById('B-upper').value)
    };
    const CRange = {
      lower: parseInt(document.getElementById('C-lower').value),
      upper: parseInt(document.getElementById('C-upper').value)
    };
        // store values in response object
        data.response = {
          A: ARange,
          B: BRange,
          C: CRange,
        };

    // Remove the sliders from the DOM after the trial finishes
    const sliderContainers = document.querySelectorAll('.slider-container, .container, .stimulus-text');
    sliderContainers.forEach(container => {
      container.remove();
    });
  }
};

    

  //------------------------------------
  // Choice trials 
  //------------------------------------
  let isPracticePhase = true; // Set this to `false` when the task phase starts

  var choiceTrials = function() {
    return { 
    timeline_variables: task_stimuli, 
    sample: {
        type: 'with-replacement',
         size: sampleSize() // use the first entry from intervR
    
      },
    timeline:
    [{
      type: jsPsychThreeArmedBandit,
      stimuli: stimuli,
      n_trials: 150,
      left_stim_number: jsPsych.timelineVariable('left_stim_number'),
      middle_stim_number: jsPsych.timelineVariable('middle_stim_number'),
      right_stim_number: jsPsych.timelineVariable('right_stim_number')
    
    }]
  };
  };

  var block = { // sample size does not vary if choiceTrials() within loop = [choiceTrials(), rating_trial] !
    // perhaps a problem with the repetition variable --> "reset" after each repetition
    // but if timeline lists all repetitions (23x [choiceTrials(), rating_trial]), the first two entries of intervR are not skipped
    // length of intervR = 23
    timeline: [choiceTrials(), ratingTrial, choiceTrials(), ratingTrial, choiceTrials(), ratingTrial, choiceTrials(), ratingTrial,
    choiceTrials(), ratingTrial, choiceTrials(), ratingTrial, choiceTrials(), ratingTrial, choiceTrials(), ratingTrial,
    choiceTrials(), ratingTrial, choiceTrials(), ratingTrial, choiceTrials(), ratingTrial, choiceTrials(), ratingTrial,
    choiceTrials(), ratingTrial, choiceTrials(), ratingTrial, choiceTrials(), ratingTrial, choiceTrials(), ratingTrial,
    choiceTrials(), ratingTrial, choiceTrials(), ratingTrial, choiceTrials(), ratingTrial, choiceTrials(), ratingTrial,
    choiceTrials(), ratingTrial, choiceTrials(), ratingTrial, choiceTrials(), ratingTrial
    ], 
    repetitions: 1, //
    randomize_order: false,
    on_start: function() {
      isPracticePhase = false;
      console.log("isPracticePhase: ", isPracticePhase);
    }
    };




  //------------------------------------
  // Instructions for the choice trials
  //------------------------------------

  var start_block = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
    <p style="font-size: 20px;"><strong>You're ready to start the experiment now.</strong></p>
    <br></br>
    <p>Please place your fingers on the keys <strong>'f', 'g' and 'h'</strong>.</p>
    <p>Press any key to begin.</p>
    `,
    on_finish: function(data) {
      counter.trial = 1;  // Reset trial counter
    }
  };


  var instructions_choiceTask = {
    type: jsPsychInstructions,
    pages: [
      `
      <div style="display: flex; flex-direction: column; align-items: center; padding: 10px; gap: 10px; max-width: 1100px; margin: auto;">
          <div style="text-align: center; width: 100%; font-size: 20px;">
            <p><strong>Choice Task</strong></p>
          </div>
          <div style="text-align: left; width: 100%;">
            <p>In the present experiment, you will make a series of decisions between <strong>three choice alternatives</strong> (A, B and C). Each choice you make will reward you with <strong>points</strong>.</p>
            <p> Your goal is collect <strong>as many points as possible</strong>.</p>
            <p>In each trial, you will be presented with three options (see below). You can select any of them by pressing one of three keys:</p>
            <ul>
                    <li>Press <strong>'f'</strong> for option <strong>A</strong>.</li>
                    <li>Press <strong>'g'</strong> for option <strong>B</strong>.</li>
                    <li>Press <strong>'h'</strong> for option <strong>C</strong>.</li>
                </ul>
            <p>You will then receive a reward between 0 and 100 points, based on the option you chose. The number of points received will be displayed at the bottom of the screen.</p>
          </div>
          
          <!-- Image with Note -->
          <div style="position: relative; display: flex; justify-content: center; align-items: center; width: 100%; padding: 20px;">
            <!-- Image -->
            <img src="example_choiceTrial.png" alt="Choice Trial Example" width="800" style="display: block;">

            <!-- Note -->
            <div style="position: absolute; top: 30%; left: 3%; transform: translate(-50%, -50%); width: 200px; background-color: #f9f9f9; border: 1px solid #ccc; border-radius: 8px; padding: 10px; box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);">
              <p style="margin: 0; font-size: 14px; color: #333;"><strong>Note:</strong> Option A was chosen. 74 points were earned.</p>
              <!-- Arrow -->
              <div style="position: absolute; top: 50%; right: -10px; transform: translateY(-50%); width: 0; height: 0; border-top: 10px solid transparent; border-bottom: 10px solid transparent; border-left: 10px solid #ccc;"></div>
              <div style="position: absolute; top: 50%; right: -9px; transform: translateY(-50%); width: 0; height: 0; border-top: 9px solid transparent; border-bottom: 9px solid transparent; border-left: 9px solid #f9f9f9;"></div>
            </div>
          </div>
      </div>
    `,
    `
    <div style="display: flex; flex-direction: column; align-items: center; padding: 10px; gap: 10px; max-width: 1100px; margin: auto;">
      <div style="text-align: center; width: 100%; font-size: 20px;">
          <p><strong>Choice Task</strong></p>
      </div>
      <div style="text-align: left; width: 100%;">
        <p>The number of points you receive for each option will vary, but each option has a <strong>different average reward</strong> that you can learn over time.</p>
        <p>Occasionally, the average reward of each option will <strong>change</strong> from one trial to the next.</p>
      </div>
      <div style="display: flex; align-items: center; justify-content: center;">
        <img src="example_choiceTrial.png" alt="Choice Trial Example" width="800" style="display: block;">
      </div>
      <div style="text-align: left; width: 100%;">
        <p>You will perform <strong>three blocks</strong> of <strong>150 trials</strong>. The experiment will take approximately 30 minutes, and there is <strong>no</strong> time limit on your decisions.</p>
        <p>Before starting the main task, you will first complete <strong>five practice trials</strong> to familiarize yourself with the task. Once you’re ready, click 'Next'.</p> 
      </div>
    </div>
      `
    ], 
      show_clickable_nav: true,  // Enables navigation buttons
      button_label_next: "Next",
      button_label_previous: "Back"  // Enables the "Back" button

  };

  //------------------------------------
  // Practice trials - Choice task
  //------------------------------------

  var practice_ChoiceTrials = function() {
    return { 
    timeline_variables: task_stimuli, 
    sample: {
        type: 'with-replacement',
         size: 5 
    
      },
    timeline:
    [{
      type: jsPsychThreeArmedBandit,
      stimuli: stimuli,
      n_trials: 5,
      left_stim_number: jsPsych.timelineVariable('left_stim_number'),
      middle_stim_number: jsPsych.timelineVariable('middle_stim_number'),
      right_stim_number: jsPsych.timelineVariable('right_stim_number')
    
    }]
  };
  }; // separate reward queues for practice trials 
  

    

//------------------------------------
// Declaration of consent
//------------------------------------

var consent = {
    type: jsPsychHtmlButtonResponse,
    stimulus: `
      <div style="display: flex; flex-direction: column; align-items: center; padding: 10px; gap: 10px; max-width: 1100px; margin: auto;">
          <div style="text-align: center; width: 100%; font-size: 20px;">
            <p><strong>General Information and Declaration of Consent</strong></p>
          </div>
          <div style="text-align: left; width: 100%;">
            <p>Thank you for your interest in our research project. Enclosed you will find information about the research project, the conditions of participation and the handling of the collected data. Please read everything carefully. If you agree and want to participate in the experiment, please confirm by giving your consent below.</p>
            </div>
          <div style="text-align: left; width: 100%;">
            <p><strong>General information about the research project:</strong></p>
            <p>This study investigates how people learn and make decisions in uncertain and changing environments. The study takes about 30 minutes in total. It includes a <strong><em>choice task</em></strong> in which you have to make a series of decisions between three choice alternatives and a <strong><em>rating task</em></strong> in which you are asked to estimate the values of the choice options several times during the experiment. No special stress or harm is expected as a result of participating in this research project. Participation in the study is remunerated at <strong>10€ per hour</strong>, rounded up to the nearest minute. Even if you decide to withdraw from the study, you are still entitled to receive the corresponding remuneration for the time spent up to that point, provided that this can be clearly demonstrated (see section Voluntary participation).</p>
          </div>
          <div style="text-align: left; width: 100%;">
            <p><strong>Voluntary participation:</strong></p>
            <p>Your participation in this research project is <strong>voluntary</strong>. You can withdraw your consent to participate at any time and without giving reasons, without receiving any disadvantages. Even if you decide to withdraw from the study, you are still entitled to receive the corresponding remuneration for the time spent up to that point, provided that this can be clearly demonstrated.</p>
          </div>
          <div style="text-align: left; width: 100%;">
            <p><strong>Participation requirements:</strong></p>
            <p>The participation requirements are a <strong>minimum age of 18 years and the absence of color blindness</strong>. Those who have already participated in this study are excluded from participation.</p>
          </div>
          <div style="text-align: left; width: 100%;">
            <p><strong>Data protection and anonymity:</strong></p>
            <p><strong>No personal data are collected</strong> as part of this study. It is therefore not possible for us to personally identify you. As a user of Prolific, you have entered into a separate personal data processing agreement with Prolific (https://participant-help.prolific.co/hc/en-gb/articles/360021786554-Data-Protection-and-Privacy-GDPR). This agreement is independent of your consent related to this study and the personal data collected by Prolific will not be made available to the research team of this study at any point.</p>
          </div>
          <div style="text-align: left; width: 100%;">
            <p><strong>Use of data:</strong></p>
            <p>The results of this study may be published for teaching and research purposes (e.g. theses, scientific publications or conference papers). These results will be presented in anonymized form, i.e. without the data being able to be connected to a specific person. The fully anonymized data of this study will be made available as "open data" in an internet-based repository, if applicable. Thus, this study follows the recommendations of the German Research Foundation (DFG) for quality assurance with regard to verifiability and reproducibility of scientific results, as well as optimal data re-use. If you would like to receive information on the scientific results of the study after its completion, please send an e-mail to Henrike Flimm (Henrike.Flimm@psy.lmu.de).</p>
          </div>
          <div style="text-align: left; width: 100%;">
            <p><strong>Legal basis and revocation:</strong></p>
            <p>The legal basis for processing the aforementioned personal data is the consent pursuant to Art. 6 (1) letter a EU-DSGVO at the end of this document. You have the right to revoke the data protection consent at any time. The revocation does not affect the lawfulness of the processing carried out on the basis of the consent until the revocation. You can request an obligatory deletion of your data at any time - as long as you can provide sufficient information that allows us to identify your data. To do so, please contact the research project managers. You will not suffer any disadvantages as a result of the revocation.</p>
          </div>
          <div style="text-align: left; width: 100%;">
            <p><strong>Research project managers:</strong></p>
            <p>If you have any questions about the research project or if you want to exercise your right to withdraw your consent, please contact the research project managers:</p>
            <p>Henrike Flimm: <a href="mailto:Henrike.Flimm@psy.lmu.de">Henrike.Flimm@psy.lmu.de</a><br>
            Prof. Dr. Christopher Donkin: <a href="mailto:c.donkin@psy.lmu.de">c.donkin@psy.lmu.de</a></p>
            <p>Ludwig-Maximilians-Universität München<br>
            Department Psychologie<br>
            Lehrstuhl für Computational Modeling in Psychology<br>
            Akademiestr. 7<br>
            80799 München</p>
          </div>
          <div style="text-align: left;">
            <p><strong>Further contact addresses:</strong></p>
            <p>You can also contact the data protection officer of the research institution or the competent supervisory authority if you have any data protection concerns in connection with this study and/or wish to lodge a complaint.</p>
            <p>Ludwig-Maximilians-Universität München<br>
            Behördlicher Datenschutzbeauftragter<br>
            Geschwister-Scholl-Platz 1<br>
            D-80539 München<br>
            Bayerisches Landesamt für Datenschutzaufsicht<br>
            Promenade 27<br>
            91522 Ansbach</p>
            <br>
            <p>Date: Month, Day, 2025</p>
            <p><strong>Declaration of consent.</strong> I hereby certify that I have read and understood the participant information described above and that I agree to the conditions stated. I agree in accordance with Art. 6 (1) letter a EU-DSGVO. I have been informed about my right to revoke my data protection consent.</p>
            <p><strong>Declaration of fulfillment inclusion criteria.</strong> I hereby confirm that I meet the above conditions for participation (18+ years old, absence of color blindness, first-time participation).</p>
          </div>
      </div>
      <style>
        .jspsych-content {
          padding-bottom: 100px; /* Adds space between the buttons and the bottom of the screen */
        }
        .jspsych-html-button-response-button {
          margin-top: 70px; /* Adds space between the text and the buttons */
        }
      </style>
    `,
    choices: ["I consent.", "I do not consent."], // redirection if data.response == 1 !
    button_html: '<button style="font-size: 17px; height: 50px;">%choice%</button>',
    on_finish: function(data){
        // execute timeline if response == 0 ("I consent."), skip if response == 1 ("I do not consent.")
        if(data.response == 1){
          jsPsych.endExperiment('<p style="width: 800px;">As you have indicated that you do <u>not</u> consent to participate in this study, please return this submission on Prolific by selecting the "<u>stop without completing</u>" button.</p><p>Thank you for your time.</p>');
        }
      }

  };


//------------------------------------
// Survey
//------------------------------------
var survey = { 
    type: jsPsychSurvey,
    survey_json: {
      pages: [{
      showQuestionNumbers: false,
      elements:
      [
        { // intro page
          type: 'html',
          html: `
          <div style="text-align:left; margin-top:50px;">
          <strong>Thank you for participating in the experiment.</strong><br><br>Before concluding, please complete the following questionnaire to help us better understand <strong>your thoughts about the task</strong> you performed.<br><br>Please answer the questions as honestly and spontaneously as possible. Your answers do <strong>not</strong> affect the financial reward that you will receive for participation.<br><br> If any question is unclear or no answer applies to you directly, please select the answer that best reflects your perspective.<br>Your answers remain confidential and will be used for research purposes only.<br>
          </div>
          `
        }]},
      {
      elements:
      [{  
          type: 'checkbox',
          title: 'What do you think was important to learn during the task to earn many points?',
          description: "You can select multiple answers.",
          name: 'imp-env-features', 
          choices: ["The average number of points obtained from each option.",
                    "The relationship between the outcomes of the options.",
                    "A pattern in the sequence of outcomes for each option.",
                    "How likely it was that the average points for each option would change from one trial to the next.",
                    "That there was a pattern in which option was best (e.g., A-B-C, or A-B-A-B).",
                    "The variability in the number of points around the average for each option.",
                    "That some of the outcomes might have been random or due to luck.",
                    "None of the above applies to me."],
          isRequired: true,
        }, 
        {
          type: 'boolean',
          title: "The average number of points that could be obtained from each option occasionally changed throughout the experiment. Did you notice changes in the final block?", 
          name: 'change-detect',
          choices: ['Yes', 'No'], 
          showOtherItem: false,
          showSelectAllItem: false,
          showNoneItem: false,
          isRequired: true,
        },
        {
          type: 'radiogroup',
          title: 'Which statement about these changes - in the final block - do you think is true?',
          name: 'belief-cp-transfer',
          choices: [
            {text: "When the average number of points decreased for one option, it always increased for the other options."},
            {text: "The changes were unpredictable or seemed random."},
            {text: "There was an alternating pattern in the changes: the best option switched between A and C, while B was never the best option."},
            {text: "There was a cyclical pattern in the changes: the best option cycled between A, B, and C in a fixed order."},
            {text: "There wasn't a fixed order, but each option became the best at different points in time (e.g., after A and C, B was the best)."},
            ],
          showOtherItem: false,
          showSelectAllItem: false,
          showNoneItem: false,
          visibleIf: "{change-detect} = 'true'",
          isRequired: true,
        },
        {
          type: 'radiogroup',
          title: 'What did you think after detecting a change - in the final block?',
          description: "Please select the statement that best reflects your thoughts.",
          name: 'expect-cp-transfer',
          choices: ['I thought I needed to explore the options again to figure out which one was best. I did not expect a pattern in the changes.',
                    'I have noticed a pattern in the changes, so I knew which option had become the best one.',
                    'I thought that the changes must follow a pattern and I tried to figure it out.'],
          showOtherItem: false,
          showSelectAllItem: false,
          showNoneItem: false,
          visibleIf: "{change-detect} = 'true'",
          isRequired: true,
        },
        {
          type: 'radiogroup', // single choice ??
          title: "Something was different in the final block compared to the first two blocks. Do you have an idea what changed?",
          description: "If you haven't noticed any difference between the blocks, please select the last statement instead of guessing.",
          name: 'belief-rel-transfer',
          choices: ['The outcomes of the options (points) varied more in the final block, making it harder to find out what the best option is.',
                    'The outcomes of the options (points) varied less in the final block, making it easier to find out what the best option is.',
                    'There were more changes in the best option in the final block.',
                    'There was a pattern in the changes in the first two blocks, but not in the final block.',
                    'There was a pattern in the final block, but not in the first two.',
                    'There was always a pattern in the changes, but it differed between the first two and the final block.',
                    'I did not notice a change.'
          ],
          showOtherItem: false,
          showSelectAllItem: false,
          showNoneItem: false,
          isRequired: true,
        }
      ]
    }]
  },
  on_finish: function(data) {
    console.log("Full Trial Data: ", data); // Log full trial data
    console.log("Raw Responses: ", data.response); // Log raw responses field

    if (data.response) {
      try {
      // Convert JavaScript object to JSON string
      let responsesJSON = JSON.stringify(data.response);

      // Parse the JSON string to make it easier to access keys
      let responses = JSON.parse(responsesJSON);

      console.log("Parsed Responses:", responses);

      // Store parsed responses in the data object for future use
      Object.keys(responses).forEach(function(key) {
        data[key] = responses[key];
      });

    } catch (error) {
      console.error("Error parsing responses. Raw value:", data.response);
      console.error("Error details:", error);
    }
  } else {
    console.error("No responses found in data.");
  }
  }
}; // save clickHistory_survey ?


//------------------------------------
// Save data before experiment ends
//------------------------------------

var saveData = {
  type: jsPsychCallFunction,
  async: true,
  func: function(done) {
    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'write_data.php');
    xhr.setRequestHeader('Content-Type', 'application/json');
    
    // Log the data that is being sent
    console.log('Sending data to server:', jsPsych.data.get().json());
    
    xhr.onload = function() {
      if (xhr.status === 200) {
        console.log("Data successfully sent:", xhr.responseText);
      } else {
        console.error("Error saving data:", xhr.status, xhr.statusText);
      }
      done(); // This will cause the experiment to progress to the next trial
    };
    
    xhr.send(jsPsych.data.get().json()); // Send the data as JSON to the server
  }
};



// Function to save jsPsych data as a CSV file
function saveDataLocally() {
  // Get the data in CSV format
  var csvData = jsPsych.data.get().csv();

  // Create a blob from the CSV data
  var blob = new Blob([csvData], { type: 'text/csv' });

  // Create a download link
  var fileName = `experiment_data${participant_id}_${condition_assignment}.csv`;
  var url = window.URL.createObjectURL(blob);
  var a = document.createElement('a');
  a.href = url;
  a.download = fileName;
  a.click(); // Simulate a click to start the download
  window.URL.revokeObjectURL(url); // Clean up URL object
}

// Example: Add this to your experiment's timeline to provide a download option
var downloadData = {
  type: jsPsychHtmlButtonResponse,
  stimulus: '<p>Thank you for participating! Click below to download your data.</p>',
  choices: ['Download Data'],
  on_finish: function() {
    saveDataLocally();
  }
};

//------------------------------------
// Put it all in a timeline
//------------------------------------
    
  var timeline1 = [
    welcome,
    fullscreen_on,
    instructions_choiceTask,
    practice_ChoiceTrials()
  ]

  var timeline = [ 
    welcome,
    fullscreen_on,
    consent,
    instructions_choiceTask,
    practice_ChoiceTrials(),  // practice choice task
    instructions_rating,
    practice_rating_loop,     // practice rating task
    start_block,
    block,                    // block 1
    block_end,
    block,                    // block 2
    block_end,
    block,                    // block 3
    block_end,
    survey,                   // questionnaire
    expt_end,
    downloadData // save_data !! --> for now: save as local csv file
  ]

//------------------------------------
// Set up and run the experiment
//------------------------------------

  // Execute timeline.
  jsPsych.run(timeline);


</script>
</html>
